/*
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints,
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client

import okhttp3.Call
import okhttp3.Callback
import okhttp3.FormBody.Builder.add
import okhttp3.FormBody.Builder.build
import okhttp3.Headers
import okhttp3.Interceptor
import okhttp3.MediaType
import okhttp3.MultipartBody
import okhttp3.MultipartBody.Builder.addPart
import okhttp3.MultipartBody.Builder.build
import okhttp3.MultipartBody.Builder.setType
import okhttp3.OkHttpClient
import okhttp3.OkHttpClient.Builder.addInterceptor
import okhttp3.OkHttpClient.Builder.addNetworkInterceptor
import okhttp3.OkHttpClient.Builder.build
import okhttp3.OkHttpClient.Builder.interceptors
import okhttp3.Request
import okhttp3.Request.Builder.addHeader
import okhttp3.Request.Builder.build
import okhttp3.Request.Builder.header
import okhttp3.Request.Builder.method
import okhttp3.Request.Builder.tag
import okhttp3.Request.Builder.url
import okhttp3.Request.header
import okhttp3.Request.tag
import okhttp3.RequestBody
import okhttp3.Response
import okhttp3.Response.Builder.build
import okhttp3.Response.header
import okhttp3.internal.http.HttpMethod.permitsRequestBody
import okhttp3.internal.tls.OkHostnameVerifier
import okhttp3.logging.HttpLoggingInterceptor
import okio.Buffer
import okio.buffer
import okio.sink
import org.openapitools.client.auth.ApiKeyAuth
import org.openapitools.client.auth.Authentication
import org.openapitools.client.auth.HttpBasicAuth
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.io.UnsupportedEncodingException
import java.lang.reflect.Type
import java.net.URI
import java.net.URLConnection
import java.net.URLEncoder
import java.nio.file.Files
import java.nio.file.Paths
import java.security.GeneralSecurityException
import java.security.KeyStore
import java.security.SecureRandom
import java.security.cert.CertificateException
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate
import java.text.DateFormat
import java.time.LocalDate
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import java.util.Arrays
import java.util.Collections
import java.util.Date
import java.util.Objects
import java.util.concurrent.TimeUnit
import java.util.regex.Pattern
import javax.net.ssl.HostnameVerifier
import javax.net.ssl.KeyManager
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.TrustManagerFactory
import javax.net.ssl.X509TrustManager

/**
 *
 * ApiClient class.
 */
class ApiClient {
    /**
     * Get base path
     *
     * @return Base path
     */
    var basePath = "http://localhost"
        private set
    var servers: List<ServerConfiguration> = ArrayList(Arrays.asList(
            ServerConfiguration(
                    "",
                    "No description provided",
                    HashMap()
            )
    ))
        protected set
    var serverIndex: Int? = 0
        protected set
    var serverVariables: Map<String, String>? = null
        protected set

    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    var isDebugging = false
        private set
    private val defaultHeaderMap: MutableMap<String, String> = HashMap()
    private val defaultCookieMap: MutableMap<String, String> = HashMap()

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is `null`, i.e. using
     * the system's default temporary folder.
     *
     * @see [](https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html.createTempFile
    @return Temporary folder path
    ) */
    var tempFolderPath: String? = null
        private set

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    var authentications: Map<String, Authentication>
        private set

    /**
     *
     * Getter for the field `dateFormat`.
     *
     * @return a [java.text.DateFormat] object
     */
    val dateFormat: DateFormat? = null
    private val datetimeFormat: DateFormat? = null
    private val lenientDatetimeFormat = false
    private val dateLength = 0

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    var sslCaCert: InputStream? = null
        private set

    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    var isVerifyingSsl = false
        private set

    /**
     *
     * Getter for the field `keyManagers`.
     *
     * @return an array of [javax.net.ssl.KeyManager] objects
     */
    var keyManagers: Array<KeyManager>
        private set

    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    var httpClient: OkHttpClient? = null
        private set

    /**
     * Get JSON
     *
     * @return JSON object
     */
    var jSON: JSON? = null
        private set
    private var loggingInterceptor: HttpLoggingInterceptor? = null

    /**
     * Basic constructor for ApiClient
     */
    constructor() {
        init()
        initHttpClient()

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications)
    }

    /**
     * Basic constructor with custom OkHttpClient
     *
     * @param client a [okhttp3.OkHttpClient] object
     */
    constructor(client: OkHttpClient?) {
        init()
        httpClient = client

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications)
    }

    private fun initHttpClient(interceptors: List<Interceptor> = emptyList()) {
        val builder = Builder()
        builder.addNetworkInterceptor(progressInterceptor)
        for (interceptor in interceptors) {
            builder.addInterceptor(interceptor)
        }
        httpClient = builder.build()
    }

    private fun init() {
        isVerifyingSsl = true
        jSON = JSON()

        // Set default User-Agent.
        setUserAgent("OpenAPI-Generator/1.0.0/java")
        authentications = HashMap()
    }

    /**
     * Set base path
     *
     * @param basePath Base path of the URL (e.g http://localhost
     * @return An instance of OkHttpClient
     */
    fun setBasePath(basePath: String): ApiClient {
        this.basePath = basePath
        serverIndex = null
        return this
    }

    fun setServers(servers: List<ServerConfiguration>): ApiClient {
        this.servers = servers
        return this
    }

    fun setServerIndex(serverIndex: Int?): ApiClient {
        this.serverIndex = serverIndex
        return this
    }

    fun setServerVariables(serverVariables: Map<String, String>?): ApiClient {
        this.serverVariables = serverVariables
        return this
    }

    /**
     * Set HTTP client, which must never be null.
     *
     * @param newHttpClient An instance of OkHttpClient
     * @return Api Client
     * @throws java.lang.NullPointerException when newHttpClient is null
     */
    fun setHttpClient(newHttpClient: OkHttpClient): ApiClient {
        httpClient = Objects.requireNonNull(newHttpClient, "HttpClient must not be null!")
        return this
    }

    /**
     * Set JSON
     *
     * @param json JSON object
     * @return Api client
     */
    fun setJSON(json: JSON?): ApiClient {
        jSON = json
        return this
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return ApiClient
     */
    fun setVerifyingSsl(verifyingSsl: Boolean): ApiClient {
        isVerifyingSsl = verifyingSsl
        applySslSettings()
        return this
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return ApiClient
     */
    fun setSslCaCert(sslCaCert: InputStream?): ApiClient {
        this.sslCaCert = sslCaCert
        applySslSettings()
        return this
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return ApiClient
     */
    fun setKeyManagers(managers: Array<KeyManager>): ApiClient {
        keyManagers = managers
        applySslSettings()
        return this
    }

    /**
     *
     * Setter for the field `dateFormat`.
     *
     * @param dateFormat a [java.text.DateFormat] object
     * @return a [org.openapitools.client.ApiClient] object
     */
    fun setDateFormat(dateFormat: DateFormat?): ApiClient {
        JSON.setDateFormat(dateFormat)
        return this
    }

    /**
     *
     * Set SqlDateFormat.
     *
     * @param dateFormat a [java.text.DateFormat] object
     * @return a [org.openapitools.client.ApiClient] object
     */
    fun setSqlDateFormat(dateFormat: DateFormat?): ApiClient {
        JSON.setSqlDateFormat(dateFormat)
        return this
    }

    /**
     *
     * Set OffsetDateTimeFormat.
     *
     * @param dateFormat a [java.time.format.DateTimeFormatter] object
     * @return a [org.openapitools.client.ApiClient] object
     */
    fun setOffsetDateTimeFormat(dateFormat: DateTimeFormatter): ApiClient {
        JSON.setOffsetDateTimeFormat(dateFormat)
        return this
    }

    /**
     *
     * Set LocalDateFormat.
     *
     * @param dateFormat a [java.time.format.DateTimeFormatter] object
     * @return a [org.openapitools.client.ApiClient] object
     */
    fun setLocalDateFormat(dateFormat: DateTimeFormatter): ApiClient {
        JSON.setLocalDateFormat(dateFormat)
        return this
    }

    /**
     *
     * Set LenientOnJson.
     *
     * @param lenientOnJson a boolean
     * @return a [org.openapitools.client.ApiClient] object
     */
    fun setLenientOnJson(lenientOnJson: Boolean): ApiClient {
        JSON.setLenientOnJson(lenientOnJson)
        return this
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    fun getAuthentication(authName: String): Authentication? {
        return authentications[authName]
    }

    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    fun setUsername(username: String?) {
        for (auth in authentications.values) {
            if (auth is HttpBasicAuth) {
                auth.username = username
                return
            }
        }
        throw RuntimeException("No HTTP basic authentication configured!")
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    fun setPassword(password: String?) {
        for (auth in authentications.values) {
            if (auth is HttpBasicAuth) {
                auth.password = password
                return
            }
        }
        throw RuntimeException("No HTTP basic authentication configured!")
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    fun setApiKey(apiKey: String?) {
        for (auth in authentications.values) {
            if (auth is ApiKeyAuth) {
                auth.apiKey = apiKey
                return
            }
        }
        throw RuntimeException("No API key authentication configured!")
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    fun setApiKeyPrefix(apiKeyPrefix: String?) {
        for (auth in authentications.values) {
            if (auth is ApiKeyAuth) {
                auth.apiKeyPrefix = apiKeyPrefix
                return
            }
        }
        throw RuntimeException("No API key authentication configured!")
    }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    fun setAccessToken(accessToken: String?) {
        throw RuntimeException("No OAuth2 authentication configured!")
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param region Region
     * @param service Service to access to
     */
    fun setAWS4Configuration(accessKey: String?, secretKey: String?, region: String?, service: String?) {
        throw RuntimeException("No AWS4 authentication configured!")
    }

    /**
     * Helper method to set credentials for AWSV4 Signature
     *
     * @param accessKey Access Key
     * @param secretKey Secret Key
     * @param sessionToken Session Token
     * @param region Region
     * @param service Service to access to
     */
    fun setAWS4Configuration(accessKey: String?, secretKey: String?, sessionToken: String?, region: String?, service: String?) {
        throw RuntimeException("No AWS4 authentication configured!")
    }

    /**
     * Set the User-Agent header's value (by adding to the default header map).
     *
     * @param userAgent HTTP request's user agent
     * @return ApiClient
     */
    fun setUserAgent(userAgent: String): ApiClient {
        addDefaultHeader("User-Agent", userAgent)
        return this
    }

    /**
     * Add a default header.
     *
     * @param key The header's key
     * @param value The header's value
     * @return ApiClient
     */
    fun addDefaultHeader(key: String, value: String): ApiClient {
        defaultHeaderMap[key] = value
        return this
    }

    /**
     * Add a default cookie.
     *
     * @param key The cookie's key
     * @param value The cookie's value
     * @return ApiClient
     */
    fun addDefaultCookie(key: String, value: String): ApiClient {
        defaultCookieMap[key] = value
        return this
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return ApiClient
     */
    fun setDebugging(debugging: Boolean): ApiClient {
        if (debugging != isDebugging) {
            if (debugging) {
                loggingInterceptor = HttpLoggingInterceptor()
                loggingInterceptor!!.setLevel(HttpLoggingInterceptor.Level.BODY)
                httpClient = httpClient!!.newBuilder().addInterceptor(loggingInterceptor!!).build()
            } else {
                val builder: Builder = httpClient!!.newBuilder()
                builder.interceptors().remove(loggingInterceptor)
                httpClient = builder.build()
                loggingInterceptor = null
            }
        }
        isDebugging = debugging
        return this
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return ApiClient
     */
    fun setTempFolderPath(tempFolderPath: String?): ApiClient {
        this.tempFolderPath = tempFolderPath
        return this
    }

    val connectTimeout: Int
        /**
         * Get connection timeout (in milliseconds).
         *
         * @return Timeout in milliseconds
         */
        get() = httpClient!!.connectTimeoutMillis

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * [java.lang.Integer.MAX_VALUE].
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    fun setConnectTimeout(connectionTimeout: Int): ApiClient {
        httpClient = httpClient!!.newBuilder().connectTimeout(connectionTimeout.toLong(), TimeUnit.MILLISECONDS).build()
        return this
    }

    val readTimeout: Int
        /**
         * Get read timeout (in milliseconds).
         *
         * @return Timeout in milliseconds
         */
        get() = httpClient!!.readTimeoutMillis

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * [java.lang.Integer.MAX_VALUE].
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    fun setReadTimeout(readTimeout: Int): ApiClient {
        httpClient = httpClient!!.newBuilder().readTimeout(readTimeout.toLong(), TimeUnit.MILLISECONDS).build()
        return this
    }

    val writeTimeout: Int
        /**
         * Get write timeout (in milliseconds).
         *
         * @return Timeout in milliseconds
         */
        get() = httpClient!!.writeTimeoutMillis

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * [java.lang.Integer.MAX_VALUE].
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    fun setWriteTimeout(writeTimeout: Int): ApiClient {
        httpClient = httpClient!!.newBuilder().writeTimeout(writeTimeout.toLong(), TimeUnit.MILLISECONDS).build()
        return this
    }

    /**
     * Format the given parameter object into string.
     *
     * @param param Parameter
     * @return String representation of the parameter
     */
    fun parameterToString(param: Any?): String {
        return if (param == null) {
            ""
        } else if (param is Date || param is OffsetDateTime || param is LocalDate) {
            //Serialize to json string and remove the " enclosing characters
            val jsonStr = JSON.serialize(param)
            jsonStr!!.substring(1, jsonStr.length - 1)
        } else if (param is Collection<*>) {
            val b = StringBuilder()
            for (o in param) {
                if (b.length > 0) {
                    b.append(",")
                }
                b.append(o)
            }
            b.toString()
        } else {
            param.toString()
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single `Pair` object.
     *
     * Note that `value` must not be a collection.
     *
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list containing a single `Pair` object.
     */
    fun parameterToPair(name: String?, value: Any?): List<Pair> {
        val params: MutableList<Pair> = ArrayList()

        // preconditions
        if (name == null || name.isEmpty() || value == null || value is Collection<*>) {
            return params
        }
        params.add(Pair(name, parameterToString(value)))
        return params
    }

    /**
     * Formats the specified collection query parameters to a list of `Pair` objects.
     *
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param name The name of the parameter.
     * @param value The value of the parameter.
     * @return A list of `Pair` objects.
     */
    fun parameterToPairs(collectionFormat: String, name: String?, value: Collection<*>?): List<Pair> {
        val params: MutableList<Pair> = ArrayList()

        // preconditions
        if (name == null || name.isEmpty() || value == null || value.isEmpty()) {
            return params
        }

        // create the params based on the collection format
        if ("multi" == collectionFormat) {
            for (item in value) {
                params.add(Pair(name, escapeString(parameterToString(item))))
            }
            return params
        }

        // collectionFormat is assumed to be "csv" by default
        var delimiter: String? = ","

        // escape all delimiters except commas, which are URI reserved
        // characters
        if ("ssv" == collectionFormat) {
            delimiter = escapeString(" ")
        } else if ("tsv" == collectionFormat) {
            delimiter = escapeString("\t")
        } else if ("pipes" == collectionFormat) {
            delimiter = escapeString("|")
        }
        val sb = StringBuilder()
        for (item in value) {
            sb.append(delimiter)
            sb.append(escapeString(parameterToString(item)))
        }
        params.add(Pair(name, sb.substring(delimiter!!.length)))
        return params
    }

    /**
     * Formats the specified collection path parameter to a string value.
     *
     * @param collectionFormat The collection format of the parameter.
     * @param value The value of the parameter.
     * @return String representation of the parameter
     */
    fun collectionPathParameterToString(collectionFormat: String, value: Collection<*>): String {
        // create the value based on the collection format
        if ("multi" == collectionFormat) {
            // not valid for path params
            return parameterToString(value)
        }

        // collectionFormat is assumed to be "csv" by default
        var delimiter = ","
        if ("ssv" == collectionFormat) {
            delimiter = " "
        } else if ("tsv" == collectionFormat) {
            delimiter = "\t"
        } else if ("pipes" == collectionFormat) {
            delimiter = "|"
        }
        val sb = StringBuilder()
        for (item in value) {
            sb.append(delimiter)
            sb.append(parameterToString(item))
        }
        return sb.substring(delimiter.length)
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    fun sanitizeFilename(filename: String): String {
        return filename.replace(".*[/\\\\]".toRegex(), "")
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     * application/json
     * application/json; charset=UTF8
     * APPLICATION/JSON
     * application/vnd.company+json
     * "* / *" is also default to JSON
     * @param mime MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    fun isJsonMime(mime: String?): Boolean {
        val jsonMime = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$"
        return mime != null && (mime.matches(jsonMime.toRegex()) || mime == "*/*")
    }

    /**
     * Select the Accept header's value from the given accepts array:
     * if JSON exists in the given array, use it;
     * otherwise use all of them (joining into a string)
     *
     * @param accepts The accepts array to select from
     * @return The Accept header to use. If the given array is empty,
     * null will be returned (not to set the Accept header explicitly).
     */
    fun selectHeaderAccept(accepts: Array<String>): String? {
        if (accepts.size == 0) {
            return null
        }
        for (accept in accepts) {
            if (isJsonMime(accept)) {
                return accept
            }
        }
        return StringUtil.join(accepts, ",")
    }

    /**
     * Select the Content-Type header's value from the given array:
     * if JSON exists in the given array, use it;
     * otherwise use the first one of the array.
     *
     * @param contentTypes The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty,
     * returns null. If it matches "any", JSON will be used.
     */
    fun selectHeaderContentType(contentTypes: Array<String>): String? {
        if (contentTypes.size == 0) {
            return null
        }
        if (contentTypes[0] == "*/*") {
            return "application/json"
        }
        for (contentType in contentTypes) {
            if (isJsonMime(contentType)) {
                return contentType
            }
        }
        return contentTypes[0]
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str String to be escaped
     * @return Escaped string
     */
    fun escapeString(str: String?): String? {
        return try {
            URLEncoder.encode(str, "utf8").replace("\\+".toRegex(), "%20")
        } catch (e: UnsupportedEncodingException) {
            str
        }
    }

    /**
     * Deserialize response body to Java object, according to the return type and
     * the Content-Type response header.
     *
     * @param <T> Type
     * @param response HTTP response
     * @param returnType The type of the Java object
     * @return The deserialized Java object
     * @throws org.openapitools.client.ApiException If fail to deserialize response body, i.e. cannot read response body
     * or the Content-Type of the response is not supported.
    </T> */
    @Throws(ApiException::class)
    fun <T> deserialize(response: Response?, returnType: Type?): T? {
        if (response == null || returnType == null) {
            return null
        }
        if ("byte[]" == returnType.toString()) {
            // Handle binary response (byte array).
            return try {
                response.body()!!.bytes() as T
            } catch (e: IOException) {
                throw ApiException(e)
            }
        } else if (returnType == File::class.java) {
            // Handle file downloading.
            return downloadFileFromResponse(response) as T
        }
        val respBody: String?
        respBody = try {
            if (response.body() != null) response.body()!!.string() else null
        } catch (e: IOException) {
            throw ApiException(e)
        }
        if (respBody == null || "" == respBody) {
            return null
        }
        var contentType = response.headers()["Content-Type"]
        if (contentType == null) {
            // ensuring a default content type
            contentType = "application/json"
        }
        return if (isJsonMime(contentType)) {
            JSON.deserialize(respBody, returnType)
        } else if (returnType == String::class.java) {
            // Expecting string, return the raw response body.
            respBody as T
        } else {
            throw ApiException(
                    "Content type \"$contentType\" is not supported for type: $returnType",
                    response.code(),
                    response.headers().toMultimap(),
                    respBody)
        }
    }

    /**
     * Serialize the given Java object into request body according to the object's
     * class and the request Content-Type.
     *
     * @param obj The Java object
     * @param contentType The request Content-Type
     * @return The serialized request body
     * @throws org.openapitools.client.ApiException If fail to serialize the given object
     */
    @Throws(ApiException::class)
    fun serialize(obj: Any?, contentType: String?): RequestBody {
        return if (obj is ByteArray) {
            // Binary (byte array) body parameter support.
            RequestBody.create(obj as ByteArray?, parse.parse(contentType))
        } else if (obj is File) {
            // File body parameter support.
            RequestBody.create(obj as File?, parse.parse(contentType))
        } else if ("text/plain" == contentType && obj is String) {
            RequestBody.create(obj as String?, parse.parse(contentType))
        } else if (isJsonMime(contentType)) {
            val content: String?
            content = if (obj != null) {
                JSON.serialize(obj)
            } else {
                null
            }
            RequestBody.create(content, parse.parse(contentType))
        } else if (obj is String) {
            RequestBody.create(obj as String?, parse.parse(contentType))
        } else {
            throw ApiException("Content type \"$contentType\" is not supported")
        }
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @throws org.openapitools.client.ApiException If fail to read file content from response and write to disk
     * @return Downloaded file
     */
    @Throws(ApiException::class)
    fun downloadFileFromResponse(response: Response): File {
        return try {
            val file = prepareDownloadFile(response)
            val sink = file.sink().buffer()
            sink.writeAll(response.body()!!.source())
            sink.close()
            file
        } catch (e: IOException) {
            throw ApiException(e)
        }
    }

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws java.io.IOException If fail to prepare file for download
     */
    @Throws(IOException::class)
    fun prepareDownloadFile(response: Response): File {
        var filename: String? = null
        val contentDisposition = response.header("Content-Disposition")
        if (contentDisposition != null && "" != contentDisposition) {
            // Get filename from the Content-Disposition header.
            val pattern = Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?")
            val matcher = pattern.matcher(contentDisposition)
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1))
            }
        }
        var prefix: String? = null
        var suffix: String? = null
        if (filename == null) {
            prefix = "download-"
            suffix = ""
        } else {
            val pos = filename.lastIndexOf(".")
            if (pos == -1) {
                prefix = "$filename-"
            } else {
                prefix = filename.substring(0, pos) + "-"
                suffix = filename.substring(pos)
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if (prefix.length < 3) prefix = "download-"
        }
        return if (tempFolderPath == null) Files.createTempFile(prefix, suffix).toFile() else Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile()
    }

    /**
     * [.execute]
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @return ApiResponse&lt;T&gt;
     * @throws org.openapitools.client.ApiException If fail to execute the call
    </T> */
    @Throws(ApiException::class)
    fun <T> execute(call: Call?): ApiResponse<T> {
        return execute(call, null)
    }

    /**
     * Execute HTTP call and deserialize the HTTP response body into the given return type.
     *
     * @param returnType The return type used to deserialize HTTP response body
     * @param <T> The return type corresponding to (same with) returnType
     * @param call Call
     * @return ApiResponse object containing response status, headers and
     * data, which is a Java object deserialized from response body and would be null
     * when returnType is null.
     * @throws org.openapitools.client.ApiException If fail to execute the call
    </T> */
    @Throws(ApiException::class)
    fun <T> execute(call: Call?, returnType: Type?): ApiResponse<T> {
        return try {
            val response = call!!.execute()
            val data: T = handleResponse(response, returnType)
            ApiResponse(response.code(), response.headers().toMultimap(), data)
        } catch (e: IOException) {
            throw ApiException(e)
        }
    }

    /**
     * [.executeAsync]
     *
     * @param <T> Type
     * @param call An instance of the Call object
     * @param callback ApiCallback&lt;T&gt;
    </T> */
    fun <T> executeAsync(call: Call?, callback: ApiCallback<T>) {
        executeAsync(call, null, callback)
    }

    /**
     * Execute HTTP call asynchronously.
     *
     * @param <T> Type
     * @param call The callback to be executed when the API call finishes
     * @param returnType Return type
     * @param callback ApiCallback
     * @see .execute
    </T> */
    fun <T> executeAsync(call: Call?, returnType: Type?, callback: ApiCallback<T>) {
        call!!.enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                callback.onFailure(ApiException(e), 0, null)
            }

            @Throws(IOException::class)
            override fun onResponse(call: Call, response: Response) {
                val result: T
                result = try {
                    handleResponse<Any>(response, returnType) as T
                } catch (e: ApiException) {
                    callback.onFailure(e, response.code(), response.headers().toMultimap())
                    return
                } catch (e: Exception) {
                    callback.onFailure(ApiException(e), response.code(), response.headers().toMultimap())
                    return
                }
                callback.onSuccess(result, response.code(), response.headers().toMultimap())
            }
        })
    }

    /**
     * Handle the given response, return the deserialized object when the response is successful.
     *
     * @param <T> Type
     * @param response Response
     * @param returnType Return type
     * @return Type
     * @throws org.openapitools.client.ApiException If the response has an unsuccessful status code or
     * fail to deserialize the response body
    </T> */
    @Throws(ApiException::class)
    fun <T> handleResponse(response: Response, returnType: Type?): T? {
        return if (response.isSuccessful) {
            if (returnType == null || response.code() == 204) {
                // returning null if the returnType is not defined,
                // or the status code is 204 (No Content)
                if (response.body() != null) {
                    try {
                        response.body()!!.close()
                    } catch (e: Exception) {
                        throw ApiException(response.message(), e, response.code(), response.headers().toMultimap())
                    }
                }
                null
            } else {
                deserialize<T>(response, returnType)
            }
        } else {
            var respBody: String? = null
            if (response.body() != null) {
                respBody = try {
                    response.body()!!.string()
                } catch (e: IOException) {
                    throw ApiException(response.message(), e, response.code(), response.headers().toMultimap())
                }
            }
            throw ApiException(response.message(), response.code(), response.headers().toMultimap(), respBody)
        }
    }

    /**
     * Build HTTP call with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP call
     * @throws org.openapitools.client.ApiException If fail to serialize the request body object
     */
    @Throws(ApiException::class)
    fun buildCall(baseUrl: String?, path: String, method: String, queryParams: List<Pair>?, collectionQueryParams: List<Pair>?, body: Any?, headerParams: Map<String, String>, cookieParams: Map<String, String>, formParams: Map<String, Any>, authNames: Array<String>, callback: ApiCallback<*>?): Call {
        val request = buildRequest(baseUrl, path, method, queryParams, collectionQueryParams, body, headerParams, cookieParams, formParams, authNames, callback)
        return httpClient!!.newCall(request!!)
    }

    /**
     * Build an HTTP request with the given options.
     *
     * @param baseUrl The base URL
     * @param path The sub-path of the HTTP URL
     * @param method The request method, one of "GET", "HEAD", "OPTIONS", "POST", "PUT", "PATCH" and "DELETE"
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @param body The request body object
     * @param headerParams The header parameters
     * @param cookieParams The cookie parameters
     * @param formParams The form parameters
     * @param authNames The authentications to apply
     * @param callback Callback for upload/download progress
     * @return The HTTP request
     * @throws org.openapitools.client.ApiException If fail to serialize the request body object
     */
    @Throws(ApiException::class)
    fun buildRequest(baseUrl: String?, path: String, method: String, queryParams: List<Pair>?, collectionQueryParams: List<Pair>?, body: Any?, headerParams: Map<String, String>, cookieParams: Map<String, String>, formParams: Map<String, Any>, authNames: Array<String>, callback: ApiCallback<*>?): Request? {
        // aggregate queryParams (non-collection) and collectionQueryParams into allQueryParams
        val allQueryParams: MutableList<Pair> = ArrayList(queryParams)
        allQueryParams.addAll(collectionQueryParams!!)
        val url = buildUrl(baseUrl, path, queryParams, collectionQueryParams)

        // prepare HTTP request body
        val reqBody: RequestBody?
        val contentType = headerParams["Content-Type"]
        var contentTypePure = contentType
        if (contentTypePure != null && contentTypePure.contains(";")) {
            contentTypePure = contentType!!.substring(0, contentType.indexOf(";"))
        }
        if (!permitsRequestBody(method)) {
            reqBody = null
        } else if ("application/x-www-form-urlencoded" == contentTypePure) {
            reqBody = buildRequestBodyFormEncoding(formParams)
        } else if ("multipart/form-data" == contentTypePure) {
            reqBody = buildRequestBodyMultipart(formParams)
        } else if (body == null) {
            if ("DELETE" == method) {
                // allow calling DELETE without sending a request body
                reqBody = null
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create("", if (contentType == null) null else parse.parse(contentType))
            }
        } else {
            reqBody = serialize(body, contentType)
        }

        // update parameters with authentication settings
        updateParamsForAuth(authNames, allQueryParams, headerParams, cookieParams, requestBodyToString(reqBody), method, URI.create(url))
        val reqBuilder: Builder = Builder().url(url)
        processHeaderParams(headerParams, reqBuilder)
        processCookieParams(cookieParams, reqBuilder)

        // Associate callback with request (if not null) so interceptor can
        // access it when creating ProgressResponseBody
        reqBuilder.tag(callback)
        var request: Request? = null
        request = if (callback != null && reqBody != null) {
            val progressRequestBody = ProgressRequestBody(reqBody, callback)
            reqBuilder.method(method, progressRequestBody).build()
        } else {
            reqBuilder.method(method, reqBody).build()
        }
        return request
    }

    /**
     * Build full URL by concatenating base path, the given sub path and query parameters.
     *
     * @param baseUrl The base URL
     * @param path The sub path
     * @param queryParams The query parameters
     * @param collectionQueryParams The collection query parameters
     * @return The full URL
     */
    fun buildUrl(baseUrl: String?, path: String, queryParams: List<Pair>?, collectionQueryParams: List<Pair>?): String {
        val url = StringBuilder()
        if (baseUrl != null) {
            url.append(baseUrl).append(path)
        } else {
            val baseURL: String?
            baseURL = if (serverIndex != null) {
                if (serverIndex!! < 0 || serverIndex!! >= servers.size) {
                    throw ArrayIndexOutOfBoundsException(String.format(
                            "Invalid index %d when selecting the host settings. Must be less than %d", serverIndex, servers.size
                    ))
                }
                servers[serverIndex!!].URL(serverVariables)
            } else {
                basePath
            }
            url.append(baseURL).append(path)
        }
        if (queryParams != null && !queryParams.isEmpty()) {
            // support (constant) query string in `path`, e.g. "/posts?draft=1"
            var prefix: String? = if (path.contains("?")) "&" else "?"
            for (param in queryParams) {
                if (param.value != null) {
                    if (prefix != null) {
                        url.append(prefix)
                        prefix = null
                    } else {
                        url.append("&")
                    }
                    val value = parameterToString(param.value)
                    url.append(escapeString(param.name)).append("=").append(escapeString(value))
                }
            }
        }
        if (collectionQueryParams != null && !collectionQueryParams.isEmpty()) {
            var prefix: String? = if (url.toString().contains("?")) "&" else "?"
            for (param in collectionQueryParams) {
                if (param.value != null) {
                    if (prefix != null) {
                        url.append(prefix)
                        prefix = null
                    } else {
                        url.append("&")
                    }
                    val value = parameterToString(param.value)
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.name)).append("=").append(value)
                }
            }
        }
        return url.toString()
    }

    /**
     * Set header parameters to the request builder, including default headers.
     *
     * @param headerParams Header parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    fun processHeaderParams(headerParams: Map<String, String>, reqBuilder: Builder) {
        for ((key, value) in headerParams) {
            reqBuilder.header(key, parameterToString(value))
        }
        for ((key, value) in defaultHeaderMap) {
            if (!headerParams.containsKey(key)) {
                reqBuilder.header(key, parameterToString(value))
            }
        }
    }

    /**
     * Set cookie parameters to the request builder, including default cookies.
     *
     * @param cookieParams Cookie parameters in the form of Map
     * @param reqBuilder Request.Builder
     */
    fun processCookieParams(cookieParams: Map<String, String>, reqBuilder: Builder) {
        for ((key, value) in cookieParams) {
            reqBuilder.addHeader("Cookie", String.format("%s=%s", key, value))
        }
        for ((key, value) in defaultCookieMap) {
            if (!cookieParams.containsKey(key)) {
                reqBuilder.addHeader("Cookie", String.format("%s=%s", key, value))
            }
        }
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     * @param queryParams List of query parameters
     * @param headerParams Map of header parameters
     * @param cookieParams Map of cookie parameters
     * @param payload HTTP request body
     * @param method HTTP method
     * @param uri URI
     * @throws org.openapitools.client.ApiException If fails to update the parameters
     */
    @Throws(ApiException::class)
    fun updateParamsForAuth(authNames: Array<String>, queryParams: List<Pair>?, headerParams: Map<String, String>?,
                            cookieParams: Map<String, String>?, payload: String?, method: String?, uri: URI?) {
        for (authName in authNames) {
            val auth = authentications[authName]
                    ?: throw RuntimeException("Authentication undefined: $authName")
            auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri)
        }
    }

    /**
     * Build a form-encoding request body with the given form parameters.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    fun buildRequestBodyFormEncoding(formParams: Map<String, Any>): RequestBody {
        val formBuilder = Builder()
        for ((key, value) in formParams) {
            formBuilder.add(key, parameterToString(value))
        }
        return formBuilder.build()
    }

    /**
     * Build a multipart (file uploading) request body with the given form parameters,
     * which could contain text fields and file fields.
     *
     * @param formParams Form parameters in the form of Map
     * @return RequestBody
     */
    fun buildRequestBodyMultipart(formParams: Map<String, Any>): RequestBody {
        val mpBuilder: Builder = Builder().setType(MultipartBody.FORM)
        for ((key, value) in formParams) {
            if (value is File) {
                addPartToMultiPartBuilder(mpBuilder, key, value)
            } else if (value is List<*>) {
                for (item in value) {
                    if (item is File) {
                        addPartToMultiPartBuilder(mpBuilder, key, item)
                    } else {
                        addPartToMultiPartBuilder(mpBuilder, key, value)
                    }
                }
            } else {
                addPartToMultiPartBuilder(mpBuilder, key, value)
            }
        }
        return mpBuilder.build()
    }

    /**
     * Guess Content-Type header from the given file (defaults to "application/octet-stream").
     *
     * @param file The given file
     * @return The guessed Content-Type
     */
    fun guessContentTypeFromFile(file: File): String {
        val contentType = URLConnection.guessContentTypeFromName(file.name)
        return contentType ?: "application/octet-stream"
    }

    /**
     * Add a Content-Disposition Header for the given key and file to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param file The file to add to the Header
     */
    private fun addPartToMultiPartBuilder(mpBuilder: Builder, key: String, file: File) {
        val partHeaders: Headers = of.of("Content-Disposition", "form-data; name=\"" + key + "\"; filename=\"" + file.name + "\"")
        val mediaType: MediaType = parse.parse(guessContentTypeFromFile(file))
        mpBuilder.addPart(partHeaders, RequestBody.create(file, mediaType))
    }

    /**
     * Add a Content-Disposition Header for the given key and complex object to the MultipartBody Builder.
     *
     * @param mpBuilder MultipartBody.Builder
     * @param key The key of the Header element
     * @param obj The complex object to add to the Header
     */
    private fun addPartToMultiPartBuilder(mpBuilder: Builder, key: String, obj: Any?) {
        val requestBody: RequestBody
        if (obj is String) {
            requestBody = RequestBody.create(obj as String?, parse.parse("text/plain"))
        } else {
            val content: String?
            content = if (obj != null) {
                JSON.serialize(obj)
            } else {
                null
            }
            requestBody = RequestBody.create(content, parse.parse("application/json"))
        }
        val partHeaders: Headers = of.of("Content-Disposition", "form-data; name=\"$key\"")
        mpBuilder.addPart(partHeaders, requestBody)
    }

    private val progressInterceptor: Interceptor
        /**
         * Get network interceptor to add it to the httpClient to track download progress for
         * async requests.
         */
        private get() = Interceptor { chain ->
            val request = chain.request()
            val originalResponse = chain.proceed(request)
            if (request.tag() is ApiCallback<*>) {
                val callback = request.tag() as ApiCallback<*>?
                return@Interceptor originalResponse.newBuilder()
                        .body(ProgressResponseBody(originalResponse.body(), callback))
                        .build()
            }
            originalResponse
        }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private fun applySslSettings() {
        try {
            val trustManagers: Array<TrustManager>
            val hostnameVerifier: HostnameVerifier
            if (!isVerifyingSsl) {
                trustManagers = arrayOf(
                        object : X509TrustManager {
                            @Throws(CertificateException::class)
                            override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {
                            }

                            @Throws(CertificateException::class)
                            override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
                            }

                            override fun getAcceptedIssuers(): Array<X509Certificate> {
                                return arrayOf()
                            }
                        }
                )
                hostnameVerifier = HostnameVerifier { hostname, session -> true }
            } else {
                val trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
                if (sslCaCert == null) {
                    trustManagerFactory.init(null as KeyStore?)
                } else {
                    val password: CharArray? = null // Any password will work.
                    val certificateFactory = CertificateFactory.getInstance("X.509")
                    val certificates = certificateFactory.generateCertificates(sslCaCert)
                    require(!certificates.isEmpty()) { "expected non-empty set of trusted certificates" }
                    val caKeyStore = newEmptyKeyStore(password)
                    var index = 0
                    for (certificate in certificates) {
                        val certificateAlias = "ca" + index++
                        caKeyStore.setCertificateEntry(certificateAlias, certificate)
                    }
                    trustManagerFactory.init(caKeyStore)
                }
                trustManagers = trustManagerFactory.trustManagers
                hostnameVerifier = OkHostnameVerifier
            }
            val sslContext = SSLContext.getInstance("TLS")
            sslContext.init(keyManagers, trustManagers, SecureRandom())
            httpClient = httpClient!!.newBuilder()
                    .sslSocketFactory(sslContext.socketFactory, (trustManagers[0] as X509TrustManager))
                    .hostnameVerifier(hostnameVerifier)
                    .build()
        } catch (e: GeneralSecurityException) {
            throw RuntimeException(e)
        }
    }

    @Throws(GeneralSecurityException::class)
    private fun newEmptyKeyStore(password: CharArray?): KeyStore {
        return try {
            val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
            keyStore.load(null, password)
            keyStore
        } catch (e: IOException) {
            throw AssertionError(e)
        }
    }

    /**
     * Convert the HTTP request body to a string.
     *
     * @param requestBody The HTTP request object
     * @return The string representation of the HTTP request body
     * @throws org.openapitools.client.ApiException If fail to serialize the request body object into a string
     */
    @Throws(ApiException::class)
    private fun requestBodyToString(requestBody: RequestBody?): String {
        return if (requestBody != null) {
            try {
                val buffer = Buffer()
                requestBody.writeTo(buffer)
                buffer.readUtf8()
            } catch (e: IOException) {
                throw ApiException(e)
            }
        } else ""

        // empty http request body
    }
}
