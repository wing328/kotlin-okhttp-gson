/*
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints,
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.model

import com.google.gson.Gson
import com.google.gson.JsonElement
import com.google.gson.TypeAdapter
import com.google.gson.TypeAdapterFactory
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonWriter
import org.openapitools.client.JSON
import java.io.IOException
import java.util.Objects
import javax.annotation.Generated

/**
 * A category for a pet
 */
@Generated(value = ["org.openapitools.codegen.languages.JavaClientCodegen"], date = "2024-04-14T17:24:37.248933300+08:00[Asia/Hong_Kong]", comments = "Generator version: 7.5.0-SNAPSHOT")
class Category {
    /**
     * Get id
     * @return id
     */
    @SerializedName(SERIALIZED_NAME_ID)
    var id: Long? = null

    /**
     * Get name
     * @return name
     */
    @SerializedName(SERIALIZED_NAME_NAME)
    var name: String? = null
    fun id(id: Long?): Category {
        this.id = id
        return this
    }

    fun name(name: String?): Category {
        this.name = name
        return this
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || javaClass != o.javaClass) {
            return false
        }
        val category = o as Category
        return id == category.id && name == category.name
    }

    override fun hashCode(): Int {
        return Objects.hash(id, name)
    }

    override fun toString(): String {
        val sb = StringBuilder()
        sb.append("class Category {\n")
        sb.append("    id: ").append(toIndentedString(id)).append("\n")
        sb.append("    name: ").append(toIndentedString(name)).append("\n")
        sb.append("}")
        return sb.toString()
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private fun toIndentedString(o: Any?): String {
        return o?.toString()?.replace("\n", "\n    ") ?: "null"
    }

    class CustomTypeAdapterFactory : TypeAdapterFactory {
        override fun <T> create(gson: Gson, type: TypeToken<T>): TypeAdapter<T> {
            if (!Category::class.java.isAssignableFrom(type.rawType)) {
                return null // this class only serializes 'Category' and its subtypes
            }
            val elementAdapter = gson.getAdapter(JsonElement::class.java)
            val thisAdapter = gson.getDelegateAdapter(this, TypeToken.get(Category::class.java))
            return object : TypeAdapter<Category>() {
                @Throws(IOException::class)
                override fun write(out: JsonWriter, value: Category) {
                    val obj = thisAdapter.toJsonTree(value).getAsJsonObject()
                    elementAdapter.write(out, obj)
                }

                @Throws(IOException::class)
                override fun read(`in`: JsonReader): Category {
                    val jsonElement = elementAdapter.read(`in`)
                    validateJsonElement(jsonElement)
                    return thisAdapter.fromJsonTree(jsonElement)
                }
            }.nullSafe() as TypeAdapter<T>
        }
    }

    /**
     * Convert an instance of Category to an JSON string
     *
     * @return JSON string
     */
    fun toJson(): String {
        return JSON.getGson().toJson(this)
    }

    companion object {
        const val SERIALIZED_NAME_ID = "id"
        const val SERIALIZED_NAME_NAME = "name"
        var openapiFields: HashSet<String>? = null
        var openapiRequiredFields: HashSet<String>? = null

        init {
            // a set of all properties/fields (JSON key names)
            openapiFields = HashSet()
            openapiFields!!.add("id")
            openapiFields!!.add("name")

            // a set of required properties/fields (JSON key names)
            openapiRequiredFields = HashSet()
        }

        /**
         * Validates the JSON Element and throws an exception if issues found
         *
         * @param jsonElement JSON Element
         * @throws IOException if the JSON Element is invalid with respect to Category
         */
        @Throws(IOException::class)
        fun validateJsonElement(jsonElement: JsonElement?) {
            if (jsonElement == null) {
                require(openapiRequiredFields!!.isEmpty()) {  // has required fields but JSON element is null
                    String.format("The required field(s) %s in Category is not found in the empty JSON string", openapiRequiredFields.toString())
                }
            }
            val entries = jsonElement!!.getAsJsonObject().entrySet()
            // check to see if the JSON string contains additional fields
            for ((key) in entries) {
                require(openapiFields!!.contains(key)) { String.format("The field `%s` in the JSON string is not defined in the `Category` properties. JSON: %s", key, jsonElement.toString()) }
            }
            val jsonObj = jsonElement.getAsJsonObject()
            require(!(jsonObj["name"] != null && !jsonObj["name"].isJsonNull && !jsonObj["name"].isJsonPrimitive)) { String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj["name"].toString()) }
        }

        /**
         * Create an instance of Category given an JSON string
         *
         * @param jsonString JSON string
         * @return An instance of Category
         * @throws IOException if the JSON string is invalid with respect to Category
         */
        @Throws(IOException::class)
        fun fromJson(jsonString: String?): Category {
            return JSON.getGson().fromJson(jsonString, Category::class.java)
        }
    }
}
