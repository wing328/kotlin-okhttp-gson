/*
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints,
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.model

import com.google.gson.Gson
import com.google.gson.JsonElement
import com.google.gson.TypeAdapter
import com.google.gson.TypeAdapterFactory
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonWriter
import org.openapitools.client.JSON
import java.io.IOException
import java.util.Objects
import javax.annotation.Generated

/**
 * Apple
 */
@Generated(value = ["org.openapitools.codegen.languages.JavaClientCodegen"], date = "2024-04-14T17:24:37.248933300+08:00[Asia/Hong_Kong]", comments = "Generator version: 7.5.0-SNAPSHOT")
class Apple {
    /**
     * Get cultivar
     * @return cultivar
     */
    @SerializedName(SERIALIZED_NAME_CULTIVAR)
    var cultivar: String? = null

    /**
     * Get origin
     * @return origin
     */
    @SerializedName(SERIALIZED_NAME_ORIGIN)
    var origin: String? = null
    fun cultivar(cultivar: String?): Apple {
        this.cultivar = cultivar
        return this
    }

    fun origin(origin: String?): Apple {
        this.origin = origin
        return this
    }

    override fun equals(o: Any?): Boolean {
        if (this === o) {
            return true
        }
        if (o == null || javaClass != o.javaClass) {
            return false
        }
        val apple = o as Apple
        return cultivar == apple.cultivar && origin == apple.origin
    }

    override fun hashCode(): Int {
        return Objects.hash(cultivar, origin)
    }

    override fun toString(): String {
        val sb = StringBuilder()
        sb.append("class Apple {\n")
        sb.append("    cultivar: ").append(toIndentedString(cultivar)).append("\n")
        sb.append("    origin: ").append(toIndentedString(origin)).append("\n")
        sb.append("}")
        return sb.toString()
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private fun toIndentedString(o: Any?): String {
        return o?.toString()?.replace("\n", "\n    ") ?: "null"
    }

    class CustomTypeAdapterFactory : TypeAdapterFactory {
        override fun <T> create(gson: Gson, type: TypeToken<T>): TypeAdapter<T> {
            if (!Apple::class.java.isAssignableFrom(type.rawType)) {
                return null // this class only serializes 'Apple' and its subtypes
            }
            val elementAdapter = gson.getAdapter(JsonElement::class.java)
            val thisAdapter = gson.getDelegateAdapter(this, TypeToken.get(Apple::class.java))
            return object : TypeAdapter<Apple>() {
                @Throws(IOException::class)
                override fun write(out: JsonWriter, value: Apple) {
                    val obj = thisAdapter.toJsonTree(value).getAsJsonObject()
                    elementAdapter.write(out, obj)
                }

                @Throws(IOException::class)
                override fun read(`in`: JsonReader): Apple {
                    val jsonElement = elementAdapter.read(`in`)
                    validateJsonElement(jsonElement)
                    return thisAdapter.fromJsonTree(jsonElement)
                }
            }.nullSafe() as TypeAdapter<T>
        }
    }

    /**
     * Convert an instance of Apple to an JSON string
     *
     * @return JSON string
     */
    fun toJson(): String {
        return JSON.getGson().toJson(this)
    }

    companion object {
        const val SERIALIZED_NAME_CULTIVAR = "cultivar"
        const val SERIALIZED_NAME_ORIGIN = "origin"
        var openapiFields: HashSet<String>? = null
        var openapiRequiredFields: HashSet<String>? = null

        init {
            // a set of all properties/fields (JSON key names)
            openapiFields = HashSet()
            openapiFields!!.add("cultivar")
            openapiFields!!.add("origin")

            // a set of required properties/fields (JSON key names)
            openapiRequiredFields = HashSet()
        }

        /**
         * Validates the JSON Element and throws an exception if issues found
         *
         * @param jsonElement JSON Element
         * @throws IOException if the JSON Element is invalid with respect to Apple
         */
        @Throws(IOException::class)
        fun validateJsonElement(jsonElement: JsonElement?) {
            if (jsonElement == null) {
                require(openapiRequiredFields!!.isEmpty()) {  // has required fields but JSON element is null
                    String.format("The required field(s) %s in Apple is not found in the empty JSON string", openapiRequiredFields.toString())
                }
            }
            val entries = jsonElement!!.getAsJsonObject().entrySet()
            // check to see if the JSON string contains additional fields
            for ((key) in entries) {
                require(openapiFields!!.contains(key)) { String.format("The field `%s` in the JSON string is not defined in the `Apple` properties. JSON: %s", key, jsonElement.toString()) }
            }
            val jsonObj = jsonElement.getAsJsonObject()
            require(!(jsonObj["cultivar"] != null && !jsonObj["cultivar"].isJsonNull && !jsonObj["cultivar"].isJsonPrimitive)) { String.format("Expected the field `cultivar` to be a primitive type in the JSON string but got `%s`", jsonObj["cultivar"].toString()) }
            require(!(jsonObj["origin"] != null && !jsonObj["origin"].isJsonNull && !jsonObj["origin"].isJsonPrimitive)) { String.format("Expected the field `origin` to be a primitive type in the JSON string but got `%s`", jsonObj["origin"].toString()) }
        }

        /**
         * Create an instance of Apple given an JSON string
         *
         * @param jsonString JSON string
         * @return An instance of Apple
         * @throws IOException if the JSON string is invalid with respect to Apple
         */
        @Throws(IOException::class)
        fun fromJson(jsonString: String?): Apple {
            return JSON.getGson().fromJson(jsonString, Apple::class.java)
        }
    }
}
