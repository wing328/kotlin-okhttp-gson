/*
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints,
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client

import com.fasterxml.jackson.databind.util.StdDateFormat
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import com.google.gson.JsonElement
import com.google.gson.JsonParseException
import com.google.gson.TypeAdapter
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonToken
import com.google.gson.stream.JsonWriter
import io.gsonfire.GsonFireBuilder
import io.gsonfire.TypeSelector
import okio.ByteString
import org.openapitools.client.model.Apple
import org.openapitools.client.model.AppleReq
import org.openapitools.client.model.Banana
import org.openapitools.client.model.BananaReq
import org.openapitools.client.model.BasquePig
import org.openapitools.client.model.Category
import org.openapitools.client.model.DanishPig
import org.openapitools.client.model.Fruit
import org.openapitools.client.model.FruitReq
import org.openapitools.client.model.GmFruit
import org.openapitools.client.model.Mammal
import org.openapitools.client.model.Pet
import org.openapitools.client.model.Pig
import org.openapitools.client.model.Tag
import org.openapitools.client.model.Whale
import org.openapitools.client.model.Zebra
import java.io.IOException
import java.io.StringReader
import java.lang.reflect.Type
import java.sql.Date
import java.text.DateFormat
import java.text.ParseException
import java.time.LocalDate
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter
import java.util.TimeZone

/*
 * A JSON utility class
 *
 * NOTE: in the future, this class may be converted to static, which may break
 *       backward-compatibility
 */
object JSON {
    /**
     * Get Gson.
     *
     * @return Gson
     */
    /**
     * Set Gson.
     *
     * @param gson Gson
     */
    var gson: Gson? = null
    private var isLenientOnJson = false
    private val dateTypeAdapter = DateTypeAdapter()
    private val sqlDateTypeAdapter = SqlDateTypeAdapter()
    private val offsetDateTimeTypeAdapter = OffsetDateTimeTypeAdapter()
    private val localDateTypeAdapter = LocalDateTypeAdapter()
    private val byteArrayAdapter = ByteArrayAdapter()
    private val sdf = StdDateFormat()
            .withTimeZone(TimeZone.getTimeZone(ZoneId.systemDefault()))
            .withColonInTimeZone(true)
    private val dtf = DateTimeFormatter.ISO_OFFSET_DATE_TIME
    fun createGson(): GsonBuilder {
        val fireBuilder = GsonFireBuilder()
                .registerTypeSelector(Mammal::class.java, TypeSelector { readElement ->
                    val classByDiscriminatorValue: MutableMap<String, Class<*>> = HashMap()
                    classByDiscriminatorValue["Pig"] = Pig::class.java
                    classByDiscriminatorValue["whale"] = Whale::class.java
                    classByDiscriminatorValue["zebra"] = Zebra::class.java
                    classByDiscriminatorValue["mammal"] = Mammal::class.java
                    getClassByDiscriminator(classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "className"))
                })
                .registerTypeSelector(Pig::class.java, TypeSelector { readElement ->
                    val classByDiscriminatorValue: MutableMap<String, Class<*>> = HashMap()
                    classByDiscriminatorValue["BasquePig"] = BasquePig::class.java
                    classByDiscriminatorValue["DanishPig"] = DanishPig::class.java
                    classByDiscriminatorValue["Pig"] = Pig::class.java
                    getClassByDiscriminator(classByDiscriminatorValue,
                            getDiscriminatorValue(readElement, "className"))
                })
        return fireBuilder.createGsonBuilder()
    }

    private fun getDiscriminatorValue(readElement: JsonElement, discriminatorField: String): String {
        val element = readElement.getAsJsonObject()[discriminatorField]
                ?: throw IllegalArgumentException("missing discriminator field: <$discriminatorField>")
        return element.asString
    }

    /**
     * Returns the Java class that implements the OpenAPI schema for the specified discriminator value.
     *
     * @param classByDiscriminatorValue The map of discriminator values to Java classes.
     * @param discriminatorValue The value of the OpenAPI discriminator in the input data.
     * @return The Java class that implements the OpenAPI schema
     */
    private fun getClassByDiscriminator(classByDiscriminatorValue: Map<*, *>, discriminatorValue: String): Class<*> {
        return classByDiscriminatorValue[discriminatorValue] as Class<*>?
                ?: throw IllegalArgumentException("cannot determine model class of name: <$discriminatorValue>")
    }

    init {
        val gsonBuilder = createGson()
        gsonBuilder.registerTypeAdapter(java.util.Date::class.java, dateTypeAdapter)
        gsonBuilder.registerTypeAdapter(Date::class.java, sqlDateTypeAdapter)
        gsonBuilder.registerTypeAdapter(OffsetDateTime::class.java, offsetDateTimeTypeAdapter)
        gsonBuilder.registerTypeAdapter(LocalDate::class.java, localDateTypeAdapter)
        gsonBuilder.registerTypeAdapter(ByteArray::class.java, byteArrayAdapter)
        gsonBuilder.registerTypeAdapterFactory(Apple.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(AppleReq.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Banana.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(BananaReq.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(BasquePig.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Category.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(DanishPig.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Fruit.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(FruitReq.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(GmFruit.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Mammal.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Pet.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Pig.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Tag.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Whale.CustomTypeAdapterFactory())
        gsonBuilder.registerTypeAdapterFactory(Zebra.CustomTypeAdapterFactory())
        gson = gsonBuilder.create()
    }

    fun setLenientOnJson(lenientOnJson: Boolean) {
        isLenientOnJson = lenientOnJson
    }

    /**
     * Serialize the given Java object into JSON string.
     *
     * @param obj Object
     * @return String representation of the JSON
     */
    fun serialize(obj: Any?): String {
        return gson!!.toJson(obj)
    }

    /**
     * Deserialize the given JSON string to Java object.
     *
     * @param <T>        Type
     * @param body       The JSON string
     * @param returnType The type to deserialize into
     * @return The deserialized Java object
    </T> */
    fun <T> deserialize(body: String, returnType: Type): T {
        return try {
            if (isLenientOnJson) {
                val jsonReader = JsonReader(StringReader(body))
                // see https://google-gson.googlecode.com/svn/trunk/gson/docs/javadocs/com/google/gson/stream/JsonReader.html#setLenient(boolean)
                jsonReader.isLenient = true
                gson!!.fromJson(jsonReader, returnType)
            } else {
                gson!!.fromJson(body, returnType)
            }
        } catch (e: JsonParseException) {
            // Fallback processing when failed to parse JSON form response body:
            // return the response body string directly for the String return type;
            if (returnType == String::class.java) {
                body as T
            } else {
                throw e
            }
        }
    }

    fun setOffsetDateTimeFormat(dateFormat: DateTimeFormatter) {
        offsetDateTimeTypeAdapter.setFormat(dateFormat)
    }

    fun setLocalDateFormat(dateFormat: DateTimeFormatter) {
        localDateTypeAdapter.setFormat(dateFormat)
    }

    fun setDateFormat(dateFormat: DateFormat?) {
        dateTypeAdapter.setFormat(dateFormat)
    }

    fun setSqlDateFormat(dateFormat: DateFormat?) {
        sqlDateTypeAdapter.setFormat(dateFormat)
    }

    /**
     * Gson TypeAdapter for Byte Array type
     */
    class ByteArrayAdapter : TypeAdapter<ByteArray?>() {
        @Throws(IOException::class)
        override fun write(out: JsonWriter, value: ByteArray?) {
            if (value == null) {
                out.nullValue()
            } else {
                out.value(ByteString.of(*value).base64())
            }
        }

        @Throws(IOException::class)
        override fun read(`in`: JsonReader): ByteArray? {
            return when (`in`.peek()) {
                JsonToken.NULL -> {
                    `in`.nextNull()
                    null
                }

                else -> {
                    val bytesAsBase64 = `in`.nextString()
                    val byteString = ByteString.decodeBase64(bytesAsBase64)
                    byteString!!.toByteArray()
                }
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 OffsetDateTime type
     */
    class OffsetDateTimeTypeAdapter @JvmOverloads constructor(private var formatter: DateTimeFormatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME) : TypeAdapter<OffsetDateTime?>() {
        fun setFormat(dateFormat: DateTimeFormatter) {
            formatter = dateFormat
        }

        @Throws(IOException::class)
        override fun write(out: JsonWriter, date: OffsetDateTime?) {
            if (date == null) {
                out.nullValue()
            } else {
                out.value(formatter.format(date))
            }
        }

        @Throws(IOException::class)
        override fun read(`in`: JsonReader): OffsetDateTime? {
            return when (`in`.peek()) {
                JsonToken.NULL -> {
                    `in`.nextNull()
                    null
                }

                else -> {
                    var date = `in`.nextString()
                    if (date.endsWith("+0000")) {
                        date = date.substring(0, date.length - 5) + "Z"
                    }
                    OffsetDateTime.parse(date, formatter)
                }
            }
        }
    }

    /**
     * Gson TypeAdapter for JSR310 LocalDate type
     */
    class LocalDateTypeAdapter @JvmOverloads constructor(private var formatter: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE) : TypeAdapter<LocalDate?>() {
        fun setFormat(dateFormat: DateTimeFormatter) {
            formatter = dateFormat
        }

        @Throws(IOException::class)
        override fun write(out: JsonWriter, date: LocalDate?) {
            if (date == null) {
                out.nullValue()
            } else {
                out.value(formatter.format(date))
            }
        }

        @Throws(IOException::class)
        override fun read(`in`: JsonReader): LocalDate? {
            return when (`in`.peek()) {
                JsonToken.NULL -> {
                    `in`.nextNull()
                    null
                }

                else -> {
                    val date = `in`.nextString()
                    LocalDate.parse(date, formatter)
                }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.sql.Date type
     * If the dateFormat is null, a simple "yyyy-MM-dd" format will be used
     * (more efficient than SimpleDateFormat).
     */
    class SqlDateTypeAdapter : TypeAdapter<Date?> {
        private var dateFormat: DateFormat? = null

        constructor()
        constructor(dateFormat: DateFormat?) {
            this.dateFormat = dateFormat
        }

        fun setFormat(dateFormat: DateFormat?) {
            this.dateFormat = dateFormat
        }

        @Throws(IOException::class)
        override fun write(out: JsonWriter, date: Date?) {
            if (date == null) {
                out.nullValue()
            } else {
                val value: String
                value = if (dateFormat != null) {
                    dateFormat!!.format(date)
                } else {
                    date.toString()
                }
                out.value(value)
            }
        }

        @Throws(IOException::class)
        override fun read(`in`: JsonReader): Date? {
            return when (`in`.peek()) {
                JsonToken.NULL -> {
                    `in`.nextNull()
                    null
                }

                else -> {
                    val date = `in`.nextString()
                    try {
                        if (dateFormat != null) {
                            Date(dateFormat!!.parse(date).time)
                        } else Date(sdf.parse(date).time)
                    } catch (e: ParseException) {
                        throw JsonParseException(e)
                    }
                }
            }
        }
    }

    /**
     * Gson TypeAdapter for java.util.Date type
     * If the dateFormat is null, DateTimeFormatter will be used.
     */
    class DateTypeAdapter : TypeAdapter<java.util.Date?> {
        private var dateFormat: DateFormat? = null

        constructor()
        constructor(dateFormat: DateFormat?) {
            this.dateFormat = dateFormat
        }

        fun setFormat(dateFormat: DateFormat?) {
            this.dateFormat = dateFormat
        }

        @Throws(IOException::class)
        override fun write(out: JsonWriter, date: java.util.Date?) {
            if (date == null) {
                out.nullValue()
            } else {
                val value: String
                value = if (dateFormat != null) {
                    dateFormat!!.format(date)
                } else {
                    date.toInstant().atOffset(ZoneOffset.UTC).format(dtf)
                }
                out.value(value)
            }
        }

        @Throws(IOException::class)
        override fun read(`in`: JsonReader): java.util.Date? {
            return try {
                when (`in`.peek()) {
                    JsonToken.NULL -> {
                        `in`.nextNull()
                        null
                    }

                    else -> {
                        val date = `in`.nextString()
                        try {
                            if (dateFormat != null) {
                                dateFormat!!.parse(date)
                            } else sdf.parse(date)
                        } catch (e: ParseException) {
                            throw JsonParseException(e)
                        }
                    }
                }
            } catch (e: IllegalArgumentException) {
                throw JsonParseException(e)
            }
        }
    }
}
